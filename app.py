import os
from flask import Flask, render_template, request, session, redirect, url_for, jsonify
from flask_socketio import SocketIO, emit, disconnect
import secrets
import hashlib
import threading
import time
import logging
from logging.handlers import RotatingFileHandler

app = Flask(__name__)
app.config['SECRET_KEY'] = os.getenv('SECRET_KEY', secrets.token_hex(16))  # Use env var or generate random
socketio = SocketIO(app, cors_allowed_origins="*", async_mode='eventlet', ping_timeout=60, ping_interval=25)  # Optimized for WebSocket

# Logging setup
if not app.debug:
    handler = RotatingFileHandler('app.log', maxBytes=10000, backupCount=1)
    handler.setLevel(logging.INFO)
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    handler.setFormatter(formatter)
    app.logger.addHandler(handler)

# Invite codes, users, banned users, and chat history
INVITE_CODES = set(['initial_code'])  # Initial code for testing
users = {}  # {sid: {'username': str, 'role': str, 'invite_code': str}}
banned = set()
chat_history = []

# Timer for checking inactive room
inactive_timer = None
last_check_time = time.time()

def check_inactive_room():
    global inactive_timer, last_check_time
    if len(users) == 0:
        current_time = time.time()
        if current_time - last_check_time >= 60:  # 1 minute
            INVITE_CODES.clear()
            chat_history.clear()
            INVITE_CODES.add('initial_code')
            app.logger.info("Room inactive: Invite codes and chat history cleared.")
        else:
            inactive_timer = threading.Timer(10, check_inactive_room)
            inactive_timer.start()
    else:
        last_check_time = time.time()
        inactive_timer = threading.Timer(10, check_inactive_room)
        inactive_timer.start()

# Start initial timer
check_inactive_room()

@app.route('/')
def index():
    app.logger.info("Serving index.html")
    return render_template('index.html')

@app.route('/login', methods=['POST'])
def login():
    username = request.form.get('username')
    invite_code = request.form.get('invite_code')
    
    if not username or not invite_code:
        app.logger.warning("Login attempt with missing username or invite code.")
        return render_template('index.html', error="Username and invite code are required!")
    if invite_code not in INVITE_CODES:
        app.logger.warning(f"Invalid invite code: {invite_code}")
        return render_template('index.html', error="Invalid invite code!")
    if username in banned:
        app.logger.warning(f"Banned user attempted login: {username}")
        return render_template('index.html', error="You are banned!")
    
    session['username'] = username
    session['invite_code'] = invite_code
    session['role'] = 'Member'
    app.logger.info(f"User {username} logged in with role Member")
    return redirect(url_for('chat'))

@app.route('/generate_code', methods=['POST'])
def generate_code():
    username = request.form.get('username')
    if not username:
        app.logger.warning("Generate code attempt without username")
        return jsonify({'error': 'Username is required!'}), 400
    new_code = generate_secure_code()
    INVITE_CODES.add(new_code)
    session['username'] = username
    session['invite_code'] = new_code
    session['role'] = 'Owner'
    app.logger.info(f"New code generated by {username}: {new_code}")
    return jsonify({'code': new_code, 'redirect': url_for('chat')})

@app.route('/chat')
def chat():
    if 'username' not in session:
        app.logger.warning("Unauthorized chat access attempt")
        return redirect(url_for('index'))
    app.logger.info(f"User {session['username']} accessing chat with role {session['role']}")
    return render_template('chat.html', username=session['username'], role=session['role'], invite_code=session.get('invite_code'))

def generate_secure_code():
    random_bytes = secrets.token_bytes(32)
    hashed = hashlib.sha256(random_bytes).hexdigest()
    return hashed[:32]

@socketio.on('connect')
def connect(auth=None):
    username = session.get('username')
    invite_code = session.get('invite_code')
    if not username or not invite_code:
        app.logger.warning(f"Failed SocketIO connect attempt: username={username}, invite_code={invite_code}")
        disconnect()
        return
    if invite_code not in INVITE_CODES or username in banned:
        app.logger.warning(f"Invalid connect attempt: username={username}, invite_code={invite_code}")
        disconnect()
        return
    role = session.get('role', 'Member')
    users[request.sid] = {'username': username, 'role': role, 'invite_code': invite_code}
    update_user_list()
    emit('message', {'username': 'System', 'message': f'{username} ({role}) joined.', 'timestamp': time.strftime('%H:%M:%S')}, broadcast=True)
    for msg in chat_history:
        emit('message', msg)
    if role == 'Owner':
        emit('owner_code', {'code': invite_code})
    app.logger.info(f"User {username} ({role}) connected via SocketIO")

@socketio.on('disconnect')
def disconnect_handler():
    user_data = users.pop(request.sid, None)
    if user_data:
        username = user_data['username']
        role = user_data['role']
        update_user_list()
        msg = f'{username} ({role}) left.'
        chat_history.append({'username': 'System', 'message': msg, 'timestamp': time.strftime('%H:%M:%S')})
        emit('message', {'username': 'System', 'message': msg, 'timestamp': time.strftime('%H:%M:%S')}, broadcast=True)
        app.logger.info(f"User {username} ({role}) disconnected")

@socketio.on('message')
def handle_message(data):
    user_data = users.get(request.sid)
    if not user_data:
        app.logger.warning(f"Message attempt from unknown user: {request.sid}")
        return
    username = user_data['username']
    role = user_data['role']
    message = data.get('message')
    if not message:
        app.logger.warning(f"Empty message from {username}")
        return
    msg_data = {'username': username, 'role': role, 'message': message, 'timestamp': time.strftime('%H:%M:%S')}
    chat_history.append(msg_data)
    emit('message', msg_data, broadcast=True)
    app.logger.info(f"Message from {username}: {message}")

@socketio.on('kick_user')
def handle_kick(data):
    user_data = users.get(request.sid)
    if not user_data or user_data['role'] != 'Owner':
        app.logger.warning(f"Unauthorized kick attempt by {user_data.get('username') if user_data else 'unknown'}")
        return
    target = data.get('username')
    if not target or target == user_data['username']:
        app.logger.warning(f"Invalid kick attempt by {user_data['username']}: target={target}")
        return
    for sid, user in list(users.items()):
        if user['username'] == target and user['role'] != 'Owner':
            emit('force_disconnect', {'message': 'You have been kicked from the chat.'}, to=sid)
            disconnect(sid)
            msg = f'{target} was kicked.'
            chat_history.append({'username': 'System', 'message': msg, 'timestamp': time.strftime('%H:%M:%S')})
            emit('message', {'username': 'System', 'message': msg, 'timestamp': time.strftime('%H:%M:%S')}, broadcast=True)
            update_user_list()
            app.logger.info(f"User {target} kicked by {user_data['username']}")

@socketio.on('ban_user')
def handle_ban(data):
    user_data = users.get(request.sid)
    if not user_data or user_data['role'] != 'Owner':
        app.logger.warning(f"Unauthorized ban attempt by {user_data.get('username') if user_data else 'unknown'}")
        return
    target = data.get('username')
    if not target or target == user_data['username']:
        app.logger.warning(f"Invalid ban attempt by {user_data['username']}: target={target}")
        return
    banned.add(target)
    for sid, user in list(users.items()):
        if user['username'] == target and user['role'] != 'Owner':
            emit('force_disconnect', {'message': 'You have been banned from the chat.'}, to=sid)
            disconnect(sid)
    msg = f'{target} was banned.'
    chat_history.append({'username': 'System', 'message': msg, 'timestamp': time.strftime('%H:%M:%S')})
    emit('message', {'username': 'System', 'message': msg, 'timestamp': time.strftime('%H:%M:%S')}, broadcast=True)
    update_user_list()
    app.logger.info(f"User {target} banned by {user_data['username']}")

@socketio.on('close_room')
def handle_close():
    user_data = users.get(request.sid)
    if not user_data or user_data['role'] != 'Owner':
        app.logger.warning(f"Unauthorized room close attempt by {user_data.get('username') if user_data else 'unknown'}")
        return
    emit('confirm_close', {'message': 'Are you sure you want to close the room?'}, to=request.sid)

@socketio.on('confirm_close_room')
def confirm_close_room():
    user_data = users.get(request.sid)
    if not user_data or user_data['role'] != 'Owner':
        app.logger.warning(f"Unauthorized confirmed room close attempt by {user_data.get('username') if user_data else 'unknown'}")
        return
    INVITE_CODES.clear()
    chat_history.clear()
    for sid in list(users.keys()):
        emit('force_disconnect', {'message': 'The chat room has been closed.'}, to=sid)
        disconnect(sid)
    INVITE_CODES.add('initial_code')
    app.logger.info("Room closed: Invite codes and chat history cleared.")

def update_user_list():
    user_list = [{'username': user['username'], 'role': user['role']} for user in users.values()]
    emit('user_list', {'users': user_list}, broadcast=True)

if __name__ == '__main__':
    port = int(os.getenv('PORT', 5001))
    socketio.run(app, host='0.0.0.0', port=port, debug=os.getenv('FLASK_ENV') == 'development')
